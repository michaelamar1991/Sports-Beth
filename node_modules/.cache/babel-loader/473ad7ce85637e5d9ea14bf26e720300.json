{"ast":null,"code":"const debug = require(\"debug\")(\"contract:handlers\"); // eslint-disable-line no-unused-vars\n\n\nvar StatusError = require(\"./statuserror\");\n\nvar Utils = require(\"./utils\");\n\nvar Reason = require(\"./reason\");\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\n\n\nvar handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash block timeout errors at user's request.\n   * @param  {Object} context execution state\n   * @param  {Object} error   error\n   * @return {Boolean}\n   */\n  ignoreTimeoutError: function (context, error) {\n    var timedOut = error.message && error.message.includes(handlers.timeoutMessage);\n    var shouldWait = context.contract && context.contract.timeoutBlocks && context.contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    return timedOut && shouldWait;\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function (emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function (context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function (context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function (context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt); // Per web3: initial confirmation index is 0\n\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function (context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs; // Decode logs, use as receipt.logs for ease of use.\n\n    try {\n      receipt.logs = receipt.logs ? Utils.decodeLogs.call(context.contract, receipt.logs) : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    } // Emit receipt\n\n\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    } // .method(): resolve/reject receipt in handler\n\n\n    if (receipt.status !== undefined && !receipt.status) {\n      var reason = await Reason.get(context.params, context.contract.web3);\n      var error = new StatusError(context.params, receipt.transactionHash, receipt, reason);\n      return context.promiEvent.reject(error);\n    } // This object has some duplicate data but is backward compatible.\n\n\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n    this.removeListener(\"receipt\", handlers.receipt);\n  }\n};\nmodule.exports = handlers;","map":null,"metadata":{},"sourceType":"script"}