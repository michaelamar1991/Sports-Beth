{"ast":null,"code":"var Reason = require('./reason');\n\nvar handlers = require('./handlers');\n\nvar override = {\n  timeoutMessage: 'not mined within',\n  // Substring of timeout err fired by web3\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes('{');\n    message.includes('}');\n\n    if (hasReceipt) {\n      const receiptString = '{' + message.split('{')[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    var constructor = this;\n    var blockNumber = null;\n    var currentBlock = override.defaultMaxBlocks;\n    var maxBlocks = constructor.timeoutBlocks;\n    var timedOut = web3Error.message && web3Error.message.includes(override.timeoutMessage);\n    var shouldWait = maxBlocks > currentBlock; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n    if (!timedOut || !shouldWait) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      var receipt = override.extractReceipt(web3Error.message);\n\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      } // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache-cli --vmErrorsOnRPCResponse=true\n\n\n      var reason = await Reason.get(context.params, constructor.web3);\n\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += \" -- Reason given: \".concat(reason, \".\");\n      }\n\n      return context.promiEvent.reject(web3Error);\n    } // This will run every block from now until contract.timeoutBlocks\n\n\n    var listener = function (pollID) {\n      var self = this;\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.web3.eth.getTransactionReceipt(context.transactionHash).then(result => {\n        if (!result) return;\n        result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n      }).catch(err => {\n        clearInterval(pollID);\n        context.promiEvent.reject(err);\n      });\n    }; // Start polling\n\n\n    let currentPollingBlock = await constructor.web3.eth.getBlockNumber();\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.web3.eth.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\nmodule.exports = override;","map":null,"metadata":{},"sourceType":"script"}