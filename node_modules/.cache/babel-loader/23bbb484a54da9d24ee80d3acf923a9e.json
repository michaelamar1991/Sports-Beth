{"ast":null,"code":"const Web3PromiEvent = require(\"web3-core-promievent\");\n\nconst Web3Shim = require(\"truffle-interface-adapter\").Web3Shim;\n\nconst utils = require(\"../utils\");\n\nconst execute = require(\"../execute\");\n\nconst bootstrap = require(\"./bootstrap\");\n\nmodule.exports = Contract => ({\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(\"Invalid provider passed to setProvider(); provider is \".concat(provider));\n    }\n\n    this.web3.setProvider(provider);\n    this.currentProvider = provider;\n  },\n\n  new() {\n    const promiEvent = new Web3PromiEvent();\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(\"\".concat(this.contractName, \" error: contract binary not set. Can't deploy new instance.\\n\") + \"This contract may be abstract, not implement an abstract parent's methods completely\\n\" + \"or not invoke an inherited contract's constructor correctly\\n\");\n    }\n\n    const args = Array.prototype.slice.call(arguments); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n    const context = {\n      contract: this,\n      promiEvent,\n      onlyEmitReceipt: true\n    };\n    this.detectNetwork().then(({\n      blockLimit\n    }) => {\n      utils.checkLibraries.apply(this);\n      return execute.deploy.call(this, args, context, blockLimit);\n    }).catch(promiEvent.reject);\n    return promiEvent.eventEmitter;\n  },\n\n  async at(address) {\n    if (address == null || typeof address !== \"string\" || address.length !== 42) {\n      throw new Error(\"Invalid address passed to \".concat(this.contractName, \".at(): \").concat(address));\n    }\n\n    try {\n      await this.detectNetwork();\n      const onChainCode = await this.web3.eth.getCode(address);\n      await utils.checkCode(onChainCode, this.contractName, address);\n      return new this(address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  async deployed() {\n    try {\n      utils.checkProvider(this);\n      await this.detectNetwork();\n      utils.checkNetworkArtifactMatch(this);\n      utils.checkDeployment(this);\n      return new this(this.address);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[\"\".concat(network_id)] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      try {\n        const _ref = await this.web3.eth.getBlock(\"latest\"),\n              gasLimit = _ref.gasLimit;\n\n        return {\n          id: this.network_id,\n          blockLimit: gasLimit\n        };\n      } catch (error) {\n        throw error;\n      }\n    } // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n\n\n    try {\n      const chainNetworkID = await this.web3.eth.net.getId();\n\n      const _ref2 = await this.web3.eth.getBlock(\"latest\"),\n            gasLimit = _ref2.gasLimit;\n\n      return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n    } catch (error) {\n      throw error;\n    }\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = \"\".concat(network_id);\n  },\n\n  setNetworkType(networkType) {\n    if (this.web3) {\n      this.web3.setNetworkType(networkType);\n    }\n\n    this.networkType = networkType;\n  },\n\n  setWallet(wallet) {\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  link(name, address) {\n    // Case: Contract.link(instance)\n    if (typeof name === \"function\") {\n      const contract = name;\n\n      if (contract.isDeployed() === false) {\n        throw new Error(\"Cannot link contract without an address.\");\n      }\n\n      this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n      Object.keys(contract.events).forEach(topic => {\n        this.network.events[topic] = contract.events[topic];\n      });\n      return;\n    } // Case: Contract.link({<libraryName>: <address>, ... })\n\n\n    if (typeof name === \"object\") {\n      const obj = name;\n      Object.keys(obj).forEach(name => {\n        const a = obj[name];\n        this.link(name, a);\n      });\n      return;\n    } // Case: Contract.link(<libraryName>, <address>)\n\n\n    if (this._json.networks[this.network_id] == null) {\n      this._json.networks[this.network_id] = {\n        events: {},\n        links: {}\n      };\n    }\n\n    this.network.links[name] = address;\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n    let network_id; // If we have a network id passed\n\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.web3 = new Web3Shim({\n      type: temp.networkType\n    });\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    } // Copy over custom key/values to the contract class\n\n\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      } // If there's not a setter, then the property is immutable.\n\n\n      throw new Error(\"\".concat(key, \" property is immutable\"));\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});","map":null,"metadata":{},"sourceType":"script"}