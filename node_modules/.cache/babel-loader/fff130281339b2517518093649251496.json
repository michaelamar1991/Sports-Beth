{"ast":null,"code":"const debug = require(\"debug\")(\"contract:utils\"); // eslint-disable-line no-unused-vars\n\n\nconst web3Utils = require(\"web3-utils\");\n\nconst bigNumberify = require(\"ethers/utils/bignumber\").bigNumberify;\n\nconst abi = require(\"web3-eth-abi\");\n\nconst BlockchainUtils = require(\"truffle-blockchain-utils\");\n\nconst reformat = require(\"./reformat\");\n\nconst Utils = {\n  is_object(val) {\n    return typeof val === \"object\" && !Array.isArray(val);\n  },\n\n  is_big_number(val) {\n    if (typeof val !== \"object\") return false;\n    return web3Utils.isBN(val) || web3Utils.isBigNumber(val);\n  },\n\n  is_tx_params(val) {\n    if (!Utils.is_object(val)) return false;\n    if (Utils.is_big_number(val)) return false;\n    const allowed_fields = {\n      from: true,\n      to: true,\n      gas: true,\n      gasPrice: true,\n      value: true,\n      data: true,\n      nonce: true,\n      privateFor: true\n    };\n\n    for (field_name of Object.keys(val)) {\n      if (allowed_fields[field_name]) return true;\n    }\n\n    return false;\n  },\n\n  decodeLogs(_logs, isSingle) {\n    const constructor = this;\n    const logs = Utils.toTruffleLog(_logs, isSingle);\n    return logs.map(log => {\n      const logABI = constructor.events[log.topics[0]];\n\n      if (logABI == null) {\n        return null;\n      }\n\n      const copy = Utils.merge({}, log);\n      copy.event = logABI.name;\n      copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);\n\n      if (copy.data === \"0x\") {\n        copy.data = \"\";\n      }\n\n      const logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);\n      copy.args = reformat.numbers.call(constructor, logArgs, logABI.inputs);\n      delete copy.data;\n      delete copy.topics;\n      return copy;\n    }).filter(log => log != null);\n  },\n\n  toTruffleLog(events, isSingle) {\n    // Transform singletons (from event listeners) to the kind of\n    // object we find on the receipt\n    if (isSingle && typeof isSingle === \"boolean\") {\n      const temp = [];\n      temp.push(events);\n      return temp.map(log => {\n        log.data = log.raw.data;\n        log.topics = log.raw.topics;\n        return log;\n      });\n    } // Or reformat items in the existing array\n\n\n    events.forEach(event => {\n      if (event.raw) {\n        event.data = event.raw.data;\n        event.topics = event.raw.topics;\n      }\n    });\n    return events;\n  },\n\n  merge() {\n    const merged = {};\n    const args = Array.prototype.slice.call(arguments);\n\n    for (let i = 0; i < args.length; i++) {\n      const object = args[i];\n      const keys = Object.keys(object);\n\n      for (let j = 0; j < keys.length; j++) {\n        const key = keys[j];\n        const value = object[key];\n        merged[key] = value;\n      }\n    }\n\n    return merged;\n  },\n\n  parallel(arr, callback = () => {}) {\n    if (!arr.length) {\n      return callback(null, []);\n    }\n\n    let index = 0;\n    const results = new Array(arr.length);\n    arr.forEach((fn, position) => {\n      fn((err, result) => {\n        if (err) {\n          callback(err);\n\n          callback = () => {};\n        } else {\n          index++;\n          results[position] = result;\n\n          if (index >= arr.length) {\n            callback(null, results);\n          }\n        }\n      });\n    });\n  },\n\n  linkBytecode(bytecode, links) {\n    Object.keys(links).forEach(library_name => {\n      const library_address = links[library_name];\n      const regex = new RegExp(\"__\".concat(library_name, \"_+\"), \"g\");\n      bytecode = bytecode.replace(regex, library_address.replace(\"0x\", \"\"));\n    });\n    return bytecode;\n  },\n\n  // Extracts optional tx params from a list of fn arguments\n  getTxParams(methodABI, args) {\n    const constructor = this;\n    const expected_arg_count = methodABI ? methodABI.inputs.length : 0;\n    tx_params = {};\n    const last_arg = args[args.length - 1];\n\n    if (args.length === expected_arg_count + 1 && Utils.is_tx_params(last_arg)) {\n      tx_params = args.pop();\n    }\n\n    return Utils.merge(constructor.class_defaults, tx_params);\n  },\n\n  // Verifies that a contracts libraries have been linked correctly.\n  // Throws on error\n  checkLibraries() {\n    const constructor = this;\n    const regex = /__[^_]+_+/g;\n    let unlinked_libraries = constructor.binary.match(regex);\n\n    if (unlinked_libraries !== null) {\n      unlinked_libraries = unlinked_libraries.map((name // Remove underscores\n      ) => name.replace(/_/g, \"\")).sort().filter((name, index, arr) => {\n        // Remove duplicates\n        if (index + 1 >= arr.length) {\n          return true;\n        }\n\n        return name !== arr[index + 1];\n      }).join(\", \");\n      const error = \"\".concat(constructor.contractName, \" contains unresolved libraries. You must deploy and link the following libraries before you can deploy a new version of \").concat(constructor.contractName, \": \").concat(unlinked_libraries);\n      throw new Error(error);\n    }\n  },\n\n  convertToEthersBN(original) {\n    const converted = [];\n    original.forEach(item => {\n      // Recurse for arrays\n      if (Array.isArray(item)) {\n        converted.push(Utils.convertToEthersBN(item)); // Convert Web3 BN / BigNumber\n      } else if (Utils.is_big_number(item)) {\n        const ethersBN = bigNumberify(item.toString());\n        converted.push(ethersBN);\n      } else {\n        converted.push(item);\n      }\n    });\n    return converted;\n  },\n\n  bigNumberify,\n\n  /**\n   * Multiplies an ethers.js BigNumber and a number with decimal places using\n   * integer math rather than using an arbitrary floating-point library like\n   * `bignumber.js`.\n   * @param  {BigNumber} bignum            an ethers.js BigNumber (use bigNumberify)\n   * @param  {Number}    decimal           a number which has 0+ decimal places\n   * @param  {Number}    [maxPrecision=5]  the max number of signficant figures\n   *                                       `decimal` can have. (default: 5)\n   * @return {BigNumber}                   floor(bignum * decimal)\n   */\n  multiplyBigNumberByDecimal(bignum, decimal, maxPrecision) {\n    if (typeof maxPrecision === \"undefined\") {\n      maxPrecision = 5;\n    }\n\n    const significantFigures = Math.min(decimal.toString().length - 1, // length less one because `.`\n    maxPrecision);\n    const denominator = bigNumberify(10).pow(significantFigures);\n    const numerator = Math.round(decimal * denominator);\n    const secondOperand = bigNumberify(numerator).div(denominator);\n    return bignum.mul(secondOperand);\n  },\n\n  // checks if given contract instance has a set provider\n  checkProvider({\n    currentProvider,\n    contractName\n  }) {\n    if (!currentProvider) throw new Error(\"\".concat(contractName, \" error: Please call setProvider() first before calling new().\"));\n  },\n\n  // verifies current network has been assigned to contract instance\n  checkNetworkArtifactMatch({\n    networks,\n    network_id,\n    contractName\n  }) {\n    if (networks[network_id] == null) throw new Error(\"\".concat(contractName, \" has not been deployed to detected network (network/artifact mismatch)\"));\n  },\n\n  // verifies contract instance has been deployed\n  checkDeployment({\n    isDeployed,\n    contractName,\n    network_id\n  }) {\n    if (!isDeployed()) throw new Error(\"\".concat(contractName, \" has not been deployed to detected network (\").concat(network_id, \")\"));\n  },\n\n  // checks if provided contract address has on-chain code\n  checkCode(onChainCode, contractName, address) {\n    if (!onChainCode || onChainCode.replace(\"0x\", \"\").replace(/0/g, \"\") === \"\") throw new Error(\"Cannot create instance of \".concat(contractName, \"; no code at address \").concat(address));\n  },\n\n  // parses known contract instance networks\n  parseKnownNetworks({\n    networks,\n    currentProvider,\n    setNetwork,\n    network_id\n  }, gasLimit) {\n    // wrap uri matching in a promise to allow provider.send time to resolve\n    // (.send call happens in BlockchainUtils.matches)\n    return new Promise((accept, reject) => {\n      // go through all the networks that are listed as\n      // blockchain uris and see if they match\n      const uris = Object.keys(networks).filter(network => network.indexOf(\"blockchain://\") === 0);\n      const matches = uris.map(uri => BlockchainUtils.matches.bind(BlockchainUtils, uri, currentProvider));\n      Utils.parallel(matches, (err, results) => {\n        if (err) reject(err);\n\n        for (let i = 0; i < results.length; i++) {\n          if (results[i]) {\n            setNetwork(uris[i]);\n            accept({\n              id: network_id,\n              blockLimit: gasLimit\n            });\n          }\n        } // no match found!\n\n\n        accept(false);\n      });\n    });\n  },\n\n  // sets a contract instance network ID\n  async setInstanceNetworkID(TruffleContractInstance, chainNetworkID, gasLimit) {\n    // if chainNetworkID already present as network configuration, use it\n    if (TruffleContractInstance.hasNetwork(chainNetworkID)) {\n      TruffleContractInstance.setNetwork(chainNetworkID);\n      return {\n        id: TruffleContractInstance.network_id,\n        blockLimit: gasLimit\n      };\n    } // chainNetworkID not present,\n    // parse all known networks\n\n\n    const matchedNetwork = await Utils.parseKnownNetworks(TruffleContractInstance, gasLimit);\n    if (matchedNetwork) return matchedNetwork; // network unknown, trust the provider and use given chainNetworkID\n\n    TruffleContractInstance.setNetwork(chainNetworkID);\n    return {\n      id: TruffleContractInstance.network_id,\n      blockLimit: gasLimit\n    };\n  }\n\n};\nmodule.exports = Utils;","map":null,"metadata":{},"sourceType":"script"}